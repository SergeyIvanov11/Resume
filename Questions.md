Что такое ООП?
Объектно-ориентированное программирование (ООП) — методология программирования, осно-
ванная на представлении программы в виде совокупности объектов, каждый из которых является 
экземпляром определенного класса, а классы образуют иерархию наследования.
    — объектно-ориентированное программирование использует в качестве основных логических 
конструктивных элементов объекты, а не алгоритмы;
    — каждый объект является экземпляром определенного класса
    — классы образуют иерархии.
Программа считается объектно-ориентированной, только если выполнены все три указанных 
требования. В частности, программирование, не использующее наследование, называется не объек-
тно-ориентированным, а программированием с помощью абстрактных типов данных.
Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объ-
екты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему 
сообщение, в ответ на которое, объект может изменить собственное состояние.

Назовите основные принципы ООП.
    Инкапсуляция - сокрытие реализации.
    Наследование - создание новой сущности на базе уже существующей.
    Полиморфизм - возможность иметь разные формы для одной и той же сущности.
    Абстракция - набор общих характеристик.
    Посылка сообщений - форма связи, взаимодействия между сущностями.
    Переиспользование- все что перечислено выше работает на повторное использование кода.
Это единственно верный порядок парадигм ООП, так как каждая последующая использует преды-
дущие.
Что такое «инкапсуляция»?
Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с 
ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при 
последующем использовании.
Цель инкапсуляции — уйти от зависимости внешне го интерфейса класса (то, что могут использо-
вать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой измене-
ние внешнего поведения класса.
    Представим на минутку, что мы оказались в конце позапрошлого века, когда Генри Форд ещё не 
придумал конвейер, а первые попытки создать автомобиль сталкивались с критикой властей по 
поводу того, что эти коптящие монстры загрязняют воздух и пугают лошадей. Представим, что для 
управления первым паровым автомобилем необходимо было знать, как устроен паровой котёл, 
постоянно подбрасывать уголь, следить за температурой, уровнем воды. При этом для поворота 
колёс использовать два рычага, каждый из которых поворачивает одно колесо в отдельности. Ду-
маю, можно согласиться с тем, что вождение автомобиля того времени было весьма неудобным и 
трудным занятием.
    Теперь вернёмся в сегодняшний день к современным чудесам автопрома с коробкой-автоматом. 


На самом деле, по сути, ничего не изменилось. Бензонасос всё так же поставляет бензин в двига-
тель, дифференциалы обеспечивают поворот колёс на различающиеся углы, коленвал превращает 
поступательное движение поршня во вращательное движение колёс. Прогресс в другом. Сейчас все 
эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не 
задумываясь, что в это время происходит с инжектором, дроссельной заслонкой и распредвалом. 
Именно сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его 
использовать даже тем, кто не является профессионалом-автомехаником с двадцатилетним стажем. 
Это сокрытие в ООП носит название инкапсуляции.
Пример:
public class SomePhone {
    private int year;
    private String company;
    public SomePhone(int year, String company) {
        this.year = year;
        this.company = company;
    }
    private void openConnection(){
        //findComutator
        //openNewConnection...
    }
    public void call() {
        openConnection();
        System.out.println(«Вызываю номер»);
    }
    public void ring() {
        System.out.println(«Дзынь-дзынь»);
    }

}

Модификатор private делает доступными поля и методы класса только внутри данного класса. Это 
означает, что получить доступ к private полям из вне невозможно, как и нет возможности вызвать 
private методы.
Сокрытие доступа к методу openConnection, оставляет нам также возможность к свободному из-
менению внутренней реализации этого метода, так как этот метод гарантированно не используется 
другими объектами и не нарушит их работу.
Для работы с нашим объектом мы оставляем открытыми методы call и ring с помощью модифика-
тора public. Предоставление открытых методов для работы с объектом также является частью меха-
низма инкапсуляции, так как если полностью закрыть доступ к объекту – он станет бесполезным.
Что такое «наследование»?
Наследование – это свойство системы, позволяющее описать новый класс на основе уже су                     
ществующего с частично или полностью заимствующейся функциональностью.
Класс, от которого производится наследование, называется предком, базовым или родительским. 
Новый класс – потомком, наследником или производным классом.


Представим себя, на минуту, инженерами автомобильного завода. Нашей задачей является разра-
ботка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомен-
довала себя в течение многолетнего использования. Всё бы хорошо, но времена и технологии ме-
няются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой 
продукции и соответствовать современным стандартам.
    Нам необходимо выпустить целый модельный ряд автомобилей: седан, универсал и малолитраж-
ный хэтч-бэк. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за 
основу предыдущее поколение, внесём ряд конструктивных изменений. Например, добавим гидро-
усилитель руля и уменьшим зазоры между крыльями и крышкой капота, поставим противотуман-
ные фонари. Кроме того, в каждой модели будет изменена форма кузова.
    Очевидно, что все три модификации будут иметь большинство свойств прежней модели (старый 
добрый двигатель 1970 года, непробиваемая ходовая часть, зарекомендовавшая себя отличным 
образом на отечественных дорогах, коробку передач и т.д.). При этом каждая из моделей будет реа-
лизовать некоторую новую функциональность или конструктивную особенность. В данном случае, 
мы имеем дело с наследованием.
Пример: Рассмотрим пример создания класса смартфон с помощью наследования. Все беспрово-
дные телефоны работают от аккумуляторных батарей, которые имеют определенный ресурс работы 
в часах. Поэтому добавим это свойство в класс беспроводных телефонов:
public abstract class WirelessPhone extends AbstractPhone {
    private int hour;
  

 

 public WirelessPhone(int year, int hour) {

  

 

     super(year);

  

 

     this.hour = hour;

  

 

 }

}

Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс 
реализацию методов call и ring:
public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
        super(year, hour);
    }
    @Override
    public void call(int outputNumber) {
        System.out.println(«Вызываю номер « + outputNumber);
    }
  

 

 @Override

  

 

 public void ring(int inputNumber) {

  

 

     System.out.println(«Вам звонит абонент « + inputNumber);

  

 

 }

}

И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полно-
ценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые 
данной операционной системой, расширяя, таким образом, его функциональность. С помощью 


кода класс можно описать так:
public class Smartphone extends CellPhone {
    private String operationSystem;
    public Smartphone(int year, int hour, String operationSystem) {
        super(year, hour);
        this.operationSystem = operationSystem;
    }
    
    public void install(String program){
        System.out.println(«Устанавливаю « + program + «для» + operationSystem);
    }

}

Как видите, для описания класса Smartphone мы создали совсем немного нового кода, но получили 
новый класс с новой функциональностью. Использование этого принципа ООП java позволяет зна-
чительно уменьшить объем кода, а значит, и облегчить работу программисту.
Что такое «полиморфизм»?
Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без ин-
формации о типе и внутренней структуре объекта.
Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разре-
шая использование одного и того же интерфейса для задания единого набора действий. Выбор же 
конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программи-
рования. Отсюда следует ключевая особенность полиморфизма - использование объекта производ-
ного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если 
обращение к ним будет производиться по ссылке родительского типа).
    Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, 
ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить чело-
века, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее 
педали тормоза, а вместо руля – джойстик.
    Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструк-
цию, и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен 
повернуть руль, независимо от того, есть там гидроусилитель или нет. Если человеку надо доехать 
с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, незави-
симо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомо-
били имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает 
именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно 
выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого 
маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. 
Но, независимо от того, каким образом будет реализовываться движение и внутреннее функциони-
рование машины, интерфейс останется прежним.
Полиморфная переменная, это переменная, которая может принимать значения разных типов, а 
полиморфная функция, это функция у которой хотя бы один аргумент является полиморфной пере-
менной. Выделяют два вида полиморфных функций:
    ad hoc, функция ведет себя по разному для разных типов аргументов (например, функция draw() 


— рисует по разному фигуры разных типов);
    параметрический, функция ведет себя одинаково для аргументов разных типов (например, функ-
ция add() — одинаково кладет в контейнер элементы разных типов).
Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без 
информации о внутреннем устройстве объекта, называется полиморфизмом.
Пример:
Давайте представим, что нам в программе нужно описать пользователя, который может пользо-
ваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это 
сделать:
public class User {
    private String name;
    public User(String name) {
        this.name = name;
    }
    public void callAnotherUser(int number, AbstractPhone phone) {
// вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!
        phone.call(number);
    }

}

Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:
public class ThomasEdisonPhone extends AbstractPhone {
    public ThomasEdisonPhone(int year) {
        super(year);
    }
    @Override
    public void call(int outputNumber) {
        System.out.println(«Вращайте ручку»);
        System.out.println(«Сообщите номер абонента, сэр»);
    }
  

 

 @Override

  

 

 public void ring(int inputNumber) {

  

 

     System.out.println(«Телефон звонит»);

  

 

 }

}

Обычный стационарный телефон:
public class Phone extends AbstractPhone {
    public Phone(int year) {
        super(year);
    }


  

 

 @Override

  

 

 public void call(int outputNumber) {

  

 

     System.out.println(«Вызываю номер» + outputNumber);

  

 

 }

  

 

 @Override

  

 

 public void ring(int inputNumber) {

  

 

     System.out.println(«Телефон звонит»);

  

 

 }

}

И, наконец, крутой видеотелефон:
public class VideoPhone extends AbstractPhone {
    public VideoPhone(int year) {
        super(year);
    }
    @Override
    public void call(int outputNumber) {
        System.out.println(«Подключаю видеоканал для абонента « + outputNumber);
    }
  

 

 @Override

  

 

 public void ring(int inputNumber) {

  

 

     System.out.println(«У вас входящий видеовызов...» + inputNumber);

  

 

 }

}

Создадим объекты в методе main() и протестируем метод callAnotherUser:
AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
AbstractPhone phone = new Phone(1984);
AbstractPhone videoPhone=new VideoPhone(2018);
User user = new User(«Андрей»);
user.callAnotherUser(224466,firstPhone);
// Вращайте ручку
//Сообщите номер абонента, сэр
user.callAnotherUser(224466,phone);
//Вызываю номер 224466
user.callAnotherUser(224466,videoPhone);
//Подключаю видеоканал для абонента 224466
Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор 
конкретной реализации метода call внутри метода callAnotherUser производился динамически на 
основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом 
и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения 
программы.
В примерах классов телефонов, приведенных выше, мы использовали переопределение методов – 
прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения 
сигнатуры метода. По сути это является заменой метода, и именно новый метод, определенный в 
подклассе, вызывается при выполнении программы.
Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает 


компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего 
методов.
Что такое «абстракция»?
Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из рассмо-
трения частные и незначимые. Соответственно, абстракция – это набор всех таких характеристик.
    Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что 
в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях 
взаимодействия шестерёнок в коробке передач или влияния формы кузова на скорость (разве что, 
автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, 
указатель поворота он будет использовать регулярно.
Пример:
// Abstract class
abstract class Animal {
    // Abstract method (does not have a body)
    public abstract void animalSound();
    // Regular method
    public void sleep() {
        System.out.println(«Zzz»);
    }

}

// Subclass (inherit from Animal)
class Pig extends Animal {
    public void animalSound() {
        // The body of animalSound() is provided here
        System.out.println(«The pig says: wee wee»);
    }

}

class MyMainClass {
    public static void main(String[] args) {
        Pig myPig = new Pig(); // Create a Pig object
        myPig.animalSound();
        myPig.sleep();
    }

}

Что представляет собой «обмен сообщениями»?
Объекты взаимодействуют, посылая и получая сообщения. Сообщение — это запрос на выполне-
ние действия, дополненный набором аргументов, которые могут понадобиться при выполнении 
действия. В ООП посылка сообщения (вызов метода) — это единственный путь передать управ-
ление объекту. Если объект должен «отвечать» на это сообщение, то у него должна иметься соот-
ветствующий данному сообщению метод. Так же объекты, используя свои методы, могут и сами 
посылать сообщения другим объектам. Обмен сообщениями реализуется с помощью динамических 
вызовов, что приводит к чрезвычайно позднему связыванию (extreme late binding).
    Пусть требуется создать физическую модель, описывающую сталкивающиеся шары разных раз-


меров. Традиционный подход к решению этой задачи примерно таков: определяется набор данных, 
описывающих каждый шар (например, его координаты, массу и ускорение); каждому шару присва-
ивается уникальный идентификатор (например, организуется массив, значение индекса которого 
соответствует номеру шара), который позволит отличать каждый из шаров от всех других. Нако-
нец, пишется подпрограмма с названием, скажем, bounce; эта процедура должна на основе номера 
шара и его начальных параметров соответствующим образом изменять данные, описывающие шар. 
В отличие от традиционного подхода объектно-ориентированная версия программы моделирует 
каждый из шаров посредством объекта. При этом объект, соответствующий конкретному шару, 
содержит не только его параметры, но и весь код, описывающий поведение шара при различных 
взаимодействиях. Так, каждый шар будет иметь собственный метод bounce(). Вместо того, чтобы 
вызывать подпрограмму bounce с аргументом, определяющим, скажем, шар №3, необходимо будет 
передать объекту «шар №3» сообщение, предписывающее ему выполнить столкновение.
Расскажите про основные понятия ООП: «класс», 
«объект», «интерфейс».
Класс – это способ описания сущности, определяющий состояние и поведение, зависящее от этого 
состояния, а также правила для взаимодействия с данной сущностью (контракт).
С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибу-
тов, членов класса) и функций для работы с ними (методов).
С точки зрения структуры программы, класс является сложным типом данных.
Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и пове-
дение, полностью определяемое классом. Каждый объект имеет конкретные значения атрибутов и 
методы, работающие с этими значениями на основе правил, заданных в классе.
Интерфейс – это набор методов класса, доступных для использования. Интерфейсом класса будет 
являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По 
сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.
к оглавлению
В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программи-
ровании?
Преимущества:
    Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человече-
ское восприятие мира, а не на компьютерную реализацию.
    Классы позволяют проводить конструирование из полезных компонентов, обладающих просты-
ми инструментами, что позволяет абстрагироваться от деталей реализации.
    Данные и операции над ними образуют определенную сущность, и они не разносятся по всей 
программе, как нередко бывает в случае процедурного программирования, а описываются вместе. 
Локализация кода и данных улучшает наглядность и удобство сопровождения программного обе-
спечения.
    Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание вы-
полнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.
    Возможность создавать расширяемые системы.
    Использование полиморфизма оказывается полезным при:
        Обработке разнородных структур данных. Программы могут работать, не различая вида объек-
тов, что существенно упрощает код. Новые виды могут быть добавлены в любой момент.
        Изменении поведения во время исполнения. На этапе исполнения один объект может быть 
заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от 


того, какой используется объект.
        Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смо-
гут работать более чем с одним видом объектов.
        Возможности описать независимые от приложения части предметной области в виде набора 
универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавле-
ния частей, специфичных для конкретного приложения.
    Повторное использование кода:
        Сокращается время на разработку, которое может быть отдано другим задачам.
        Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем 
вновь разработанные, ведь они уже не раз подвергались проверке.
        Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в 
его код, одновременно оказывают положительное влияние и на множество работающих с ним про-
грамм.
        Если программа опирается на стандартные компоненты, ее структура и пользовательский 
интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает исполь-
зование.
Недостатки:
    В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда 
легко определить, какие поля и методы фактически относятся к данному классу.
    Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка 
сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).
    Документирование классов - задача более трудная, чем это было в случае процедур и модулей. 
Поскольку любой метод может быть переопределен, в документации должно говориться не только 
о том, что делает данный метод, но и о том, в каком контексте он вызывается.
    Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издер-
жек на динамическое связывание и проверки типов на этапе выполнения).
    Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо 
текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым 
грузом.
Что подразумевают в плане принципов ООП выражения 
«является» и «имеет»?
«является» подразумевает наследование. «имеет» подразумевает ассоциацию (агрегацию или ком-
позицию).
В чем разница между композицией и агрегацией?
Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассо-
циации «часть-целое».
Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция 
более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, 
что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в 
случае агрегации экземпляр «части» может входить в несколько целых.
    Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в дру-
гую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция. В тоже время 
мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.


Что такое статическое и динамическое связывание?
Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится 
компилятором (компоновщиком) перед запуском программы, то оно называется статическим или 
ранним связыванием (early binding).
В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во 
время выполнения программы, в зависимости от типа объекта. Позднее связывание также называ-
ют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). В языках, 
реализующих позднее связывание, должен существовать механизм определения фактического типа 
объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор 
не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее 
тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предполо-
жить, что для его реализации в объекты должна включаться какая-то дополнительная информация.
Для всех методов Java используется механизм позднего (динамического) связывания, если только 
метод не был объявлен как final (приватные методы являются final по умолчанию).


JVM


За что отвечает JVM:
    Загрузка, проверка и исполнение байт кода;
    Предоставление среды выполнения для выполнения байт-кода;
    Управление памятью и очисткой мусора (Garbage collection);
Виртуальная машина Java (Java Virtual Machine) - это механизм, предоставляющий среду выполне-
ния для управления Java-кодом или приложениями. Виртуальная машина является независимой 
оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС, без влияния ОС 
на выполняемую программу.
JVM работает с 2мя типами данных: примитивные типы (primitive types) и ссылочные типы 
(reference types).
Примитивы
JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По 
сути, JVM - это 32-битная машина. Типы long и double, которые являются 64-битными, поддержи-
ваются изначально, но занимают две единицы памяти в frame’s local или стеке операндов, поскольку 
каждая единица составляет 32 бита. Типы boolean, byte, short и char имеют расширенный знак (кро-
ме char с нулевым расширением) и работают как 32-разрядные целые числа, так же, как и типы int. 
Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хране-
ния и преобразования типов. boolean значение работает как 8-битное byte значения, где 0 представ-
ляет значение false, а 1 - значение true.
Типы ссылок и значения
Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов. Их зна-
чения являются ссылками на динамически создаваемые экземпляры классов, массивы или экзем-
пляры классов, которые реализуют интерфейсы соответственно.
Classloader
Загрузчик классов является частью JRE, которая динамически закгружает Java классы в JVM. Обыч-
но классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и 
файловых системах благодаря загрузчику классов. Делегирование является важной концепцией, 
которую выполняет загрузчик. Загрузчик классов отвечает за поиск библиотек, чтение их содер-
жимого и загрузку классов, содержащихся в библиотеках. Эта загрузка обычно выполняется «по 
требованию», поскольку она не происходит до тех пор, пока программа не вызовет класс. Класс с 
именем может быть загружен только один раз данным загрузчиком классов.
При запуске JVM, используются три загрузчика классов:
    Bootstrap class loader (Загрузчик класса Bootstrap)
    Extensions class loader (Загрузчик класса расширений)
    System class loader (Системный загрузчик классов)
Загрузчик класса Bootstrap загружает основные библиотеки Java, расположенные в папке <JAVA_
HOME>/jre/lib. Этот загрузчик является частью ядра JVM, написан на нативном коде.
Загрузчик класса расширений загружает код в каталоги расширений (<JAVA_HOME>/jre/lib/ext, или 
любой другой каталог, указанный системным свойством java.ext.dirs).
Системный загрузчик загружает код, найденный в java.class.path, который сопоставляется с пере-


менной среды CLASSPATH. Это реализуется классом sun.misc.Launcher$AppClassLoader.
Загрузчик классов выполняет три основных действия в строгом порядке:
    Загрузка: находит и импортирует двоичные данные для типа.
    Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
        Проверка: обеспечивает правильность импортируемого типа.
        Подготовка: выделяет память для переменных класса и инициализация памяти значениями по 
умолчанию.
        Разрешение: преобразует символические ссылки из типа в прямые ссылки.
    Инициализация: вызывает код Java, который инициализирует переменные класса их правильны-
ми начальными значениями.
Пользовательский загрузчик классов
Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик клас-
сов, не понимая тонких деталей JVM. У каждого загрузчика классов Java есть родительский загруз-
чик классов, определенный при создании экземпляра нового загрузчика классов или в качестве 
системного загрузчика классов по умолчанию для виртуальной машины.
Что делает возможным следующее:
    загружать или выгружать классы во время выполнения (например, динамически загружать би-
блиотеки во время выполнения, даже из ресурса HTTP). Это важная особенность для:
        реализация скриптовых языков;
        использование bean builders;
        добавить пользовательскую расширение;
        позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов 
CORBA / RMI;
    изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код 
класса Java);
    модифицировать загруженный байт-код (например, для переплетения аспектов во время загруз-
ки при использовании аспектно-ориентированного программирования);
Области данных времени выполнения
Run-Time Data Areas. JVM выделяет множество областей данных во время выполнения, к-рые ис-
пользуются во время выполнения программы. Некоторые участки данных созданы JVM во время 
старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничто-
жаются, когда поток уничтожается.
The pc Register (PCR)
Виртуальная машина Java может поддерживать много потоков исполнения одновременно. Каждый 
поток виртуальной машины Java имеет свой собственный регистр PC (programm counter). В любой 
момент каждый поток виртуальной машины Java выполняет код одного метода, а именно текущий 
метод для этого потока. Если этот метод не является native, регистр pc содержит адрес инструкции 
виртуальной машины Java, выполняемой в настоящее время.
Коротко говоря: для одного потока существует один PCR, который создается при запуске потока. 
PCR хранит адрес выполняемой сейчас инструкции JVM.
Java Virtual Machine Stacks


Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком. Стек в JVM 
хранит frames. Cтеки в JVM могут иметь фиксированный размер или динамически расширяться и 
сжиматься в соответствии с требованиями вычислений.
Heap
JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java. Куча - это 
область данных времени выполнения, из которой выделяется память для всех экземпляров и масси-
вов классов. Куча создается при запуске виртуальной машины. Хранилище для объектов восстанав-
ливается автоматической системой управления данными (известной как сборщик мусора); объекты 
никогда не освобождаются явно. JVM не предполагает какого-либо конкретного типа системы 
автоматического управления хранением данных, и метод управления может быть выбран в соответ-
ствии с системными требованиями разработчика. Куча может иметь фиксированный размер или 
может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если 
большая куча становится ненужной. Память для кучи не должна быть смежной.
Method Area
JVM имеет область методов, которая является общей для всех потоков. Она хранит структуры для 
каждого класса, такие как пул констант, данные полей и методов, а также код для методов и кон-
структоров, включая специальные методы, используемые при инициализации классов и экземпля-
ров, и инициализации интерфейса. Хотя область метода является логически частью кучи, простые 
реализации могут не обрабатываться собиращиком мусора. Область метода может иметь фикси-
рованный размер или может быть расширена в соответствии с требованиями вычислений и может 
быть сокращена, если большая область метода становится ненужной.
Run-Time Constant Pool
A run-time constant pool существует для каждого класса или интерфейса в рантайме и представ-
ленно constant_pool таблицей в *.class файле. Он содержит несколько видов констант: от числовых 
литералов, известных во время компиляции, до ссылок на методы и поля, которые должны быть 
разрешены во время выполнения. Сам run-time constant pool выполняет функцию, аналогичную 
функции таблицы символов для обычного языка программирования, хотя он содержит более ши-
рокий диапазон данных, чем типичная таблица символов. Каждый run-time constant pool отделён от 
JVM’s method area. JVM создаёт run-time constant pool вместе с созданием class или interface.
Native Method Stacks
Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые 
«стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка про-
граммирования Java).
Frames
Frame используется для хранения данных и частичных результатов, а также для выполнения дина-
мического связывания, возврата значений для методов и отправки исключений. Новый frame соз-
дается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода, 
является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). 
Frames выделяются из стека потока, создающего frame. Каждый frame имеет свой собственный мас-
сив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время 
выполнения класса текущего метода. Размеры массива локальных переменных и стека операндов 
определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с 
фреймом. Таким образом, размер структуры данных, frame-а зависит только от реализации вирту-
альной машины Java, и память для этих структур может быть выделена одновременно при вызове 


метода.
Только один frame активен в любой точке данного потока управления - метода выполнения, и это 
frame называется текущим, а его метод известен как текущий метод. Класс, в котором определен 
текущий метод, является текущим классом. Операции над локальными переменными и стеком опе-
рандов обычно выполняются со ссылкой на текущий frame.
Frame перестает быть текущим, если его метод вызывает другой метод или если его метод завер-
шается. Когда метод вызывается, новый frame создается и становится текущим, когда управление 
переходит к новому методу. При возврате метода текущий frame передает результат вызова метода, 
если таковой имеется, в предыдущий frame. Текущий frame затем отбрасывается, так как преды-
дущий frame становится текущим. Обратите внимание, что frame, созданный потоком, является 
локальным для этого потока и на него не может ссылаться ни один другой поток.
Локальные переменные
Каждый frame содержит массив переменных, известных как его локальные переменные. Длина 
массива локальных переменных frame определяется во время компиляции и предоставляется в 
двоичном представлении класса или интерфейса вместе с кодом для метода, связанного с frame-ом. 
Еденичная локальная переменная может хранить значение типа: boolean, byte, char, short, int, float, 
reference, or returnAddress. Пара локальных переменных может хранить значение типов: long или 
double.
Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен 
нулю.
Значение типа long или типа double занимает две последовательные локальные переменные.
JVM использует локальные переменные для передачи параметров при вызове метода. При вызове 
метода класса все параметры передаются в последовательных локальных переменных, начиная с 
локальной переменной 0. При вызове метода экземпляра локальная переменная 0 всегда использу-
ется для передачи ссылки на объект, для которого вызывается метод экземпляра (this в Java). Любые 
параметры впоследствии передаются в последовательных локальных переменных, начиная с ло-
кальной переменной 1.
Стеки операндов (Operand Stacks)
Каждый frame содержит стек «последний вошел - первый вышел» (LIFO), известный как стек опе-
рандов. Максимальная глубина стека операндов frame-a определяется во время компиляции и пре-
доставляется вместе с кодом для метода, связанного с frame-ом.
Стек операнда пуст при создании frame-a, который его содержит. JVM предоставляет инструкции 
для загрузки констант или значений из локальных переменных или полей в стек операндов. Другие 
инструкции JVM берут операнды из стека операндов, оперируют с ними и помещают результат об-
ратно в стек операндов. Стек операндов также используется для подготовки параметров для переда-
чи в методы и для получения результатов метода.
Для примера, инструкция iadd суммирует два int-вых значения. От стека операндов требуется, что-
бы два int-вых значения были наверху стека. Значения удаляются из стека, операция pop. Суммиру-
ются и их сумма помещается в стек операндов.
Динамическое связывание (Dynamic Linking)
Каждый frame содержит ссылку на run-time constant pool для типа текущего метода для поддержки 


динамического связывания кода метода. Доступ к вызываемым методам и переменным осуществля-
ется через символические ссылки из class файла. Динамическое связывание преобразует эти сим-
вольные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимо-
сти для разрешения пока еще не определенных символов, и преобразует обращения к переменным 
в соответствующие смещения в структурах хранения, связанных с расположением этих переменных 
во время выполнения.
Позднее связывание методов и переменных вносит изменения в другие классы, которые метод ис-
пользует с меньшей вероятностью нарушить этот код.
Нормальное завершение вызова метода
Вызов метода завершается нормально, если этот вызов не вызывает исключение, либо непосред-
ственно из JVM, либо в результате выполнения явного оператора throw. Если вызов текущего мето-
да завершается нормально, то значение может быть возвращено вызывающему методу. Это про-
исходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которых должен 
соответствовать типу возвращаемого значения (если оно есть).
Текущий frame используется в этом случае для восстановления состояния инициатора, включая его 
локальные переменные и стек операндов, с соответствующим образом увеличенным программным 
счетчиком инициатора, чтобы пропустить инструкцию вызова метода. Затем выполнение обычно 
продолжается в frame вызывающего метода с возвращенным значением (если оно есть), помещае-
мым в стек операндов этого frame.
Резкое завершение вызова метода
Вызов метода завершается преждевременно, если при выполнении инструкции JVM в методе выда-
ет исключение, и это исключение не обрабатывается в методе. Выполнение команды athrow также 
приводит к явному выбрасыванию исключения, и, если исключение не перехватывается текущим 
методом, приводит к неожиданному завершению вызова метода. Вызов метода, который завершает-
ся внезапно, никогда не возвращает значение своему вызывающему.
Execution Engine
Байт-код, назначенный run-time data areas, будет выполнен execution engine. Механизм выполнения 
считывает байт-код и выполняет его по частям.
Interpreter
Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпре-
татора заключается в том, что, когда один метод вызывается несколько раз, каждый раз требуется 
новая интерпретация.
JIT Compiler
JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать 
помощь интерпретатора при преобразовании байт-кода, но когда он находит повторный код, он 
использует JIT-компилятор, который компилирует весь байт-код и изменяет его на собственный 
код. Этот нативный код будет использоваться непосредственно для повторных вызовов методов, 
которые улучшают производительность системы.
    Генератор промежуточного кода (Intermediate Code Generator). Производит промежуточный код.
    Code Optimizer. Отвечает за оптимизацию промежуточного кода, сгенерированного выше.


    Генератор целевого кода (Target Code Generator). Отвечает за генерацию машинного кода или 
родной код.
    Профилировщик (Profiler). Специальный компонент, отвечающий за поиск горячих точек, то 
есть, вызывается ли метод несколько раз или нет.
Garbage Collector


JAVA Core


Чем различаются JRE, JVM и JDK?
JVM, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения 
Java (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исход-
ного текста Java-программы компилятором Java. JVM может также использоваться для выполнения 
программ, написанных на других языках программирования.
JRE, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реа-
лизация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного 
набора библиотек классов Java.
JDK, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика 
приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов 
Java, примеры, документацию, различные утилиты.
Коротко: JDK - среда для разработки программ на Java, включающая в себя JRE - среду для обе-
спечения запуска Java программ, которая в свою очередь содержит JVM - интерпретатор кода Java 
программ.
Какие существуют модификаторы доступа?
private (приватный): члены класса доступны только внутри класса. Для обозначения используется 
служебное слово private.
default, package-private, package level (доступ на уровне пакета): видимость класса/членов класса 
только внутри пакета. Является модификатором доступа по умолчанию - специальное обозначение 
не требуется.
protected (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения 
используется служебное слово protected.
public (публичный): класс/члены класса доступны всем. Для обозначения используется служебное 
слово public.
Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, 
private.
Во время наследования возможно изменения модификаторов доступа в сторону большей видимо-
сти (для поддержания соответствия принципу подстановки Барбары Лисков).
О чем говорит ключевое слово final?
Модификатор final может применяться к переменным, параметрам методов, полям и методам клас-
са или самим классам.
    - Класс не может иметь наследников;
    - Метод не может быть переопределен в классах наследниках;
    - Поле не может изменить свое значение после инициализации;
    - Параметры методов не могут изменять своё значение внутри метода;
    - Локальные переменные не могут быть изменены после присвоения им значения.


Какими значениями инициализируются переменные по 
умолчанию?
    Числа инициализируются 0 или 0.0;
    char — \u0000;
    boolean — false;
    Объекты (в том числе String) — null.
Что вы знаете о функции main()?
Метод main() — точка входа в программу. В приложении может быть несколько таких методов. 
Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка `Error: 
Main method not found`.
public static void main(String[] args) {}
Какие логические операции и операторы вы знаете?
    &: Логическое AND (И);
    &&: Сокращённое AND;
    |: Логическое OR (ИЛИ);
    ||: Сокращённое OR;
    ^: Логическое XOR (исключающее OR (ИЛИ));
    !: Логическое унарное NOT (НЕ);
    &=: AND с присваиванием;
    |=: OR с присваиванием;
    ^=: XOR с присваиванием;
    ==: Равно;
    !=: Не равно;
    ?:: Тернарный (троичный) условный оператор.
Что такое тернарный оператор выбора?
Тернарный условный оператор ?: - оператор, которым можно заменить некоторые конструкции 
операторов if-then-else.
Выражение записывается в следующей форме:
    условие ? выражение1 : выражение2
Если условие выполняется, то вычисляется выражение1 и его результат становится результатом 
выполнения всего оператора. Если же условие равно false, то вычисляется выражение2 и его значе-
ние становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны 
возвращать значение одинакового (или совместимого) типа.
Какие побитовые операции вы знаете?
    ~: Побитовый унарный оператор NOT;
    &: Побитовый AND;
    &=: Побитовый AND с присваиванием;
    |: Побитовый OR;
    |=: Побитовый OR с присваиванием;


    ^: Побитовый исключающее XOR;
    ^=: Побитовый исключающее XOR с присваиванием;
    >>: Сдвиг вправо (деление на 2 в степени сдвига);
    >>=: Сдвиг вправо с присваиванием;
    >>>: Сдвиг вправо без учёта знака;
    >>>=: Сдвиг вправо без учёта знака с присваиванием;
    <<: Сдвиг влево (умножение на 2 в степени сдвига);
    <<=: Сдвиг влево с присваиванием.
Где и для чего используется модификатор abstract?
Класс помеченный модификатором abstract называется абстрактным классом. Такие классы могут 
выступать только предками для других классов. Создавать экземпляры самого абстрактного класса 
не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные 
классы, так и классы, допускающие создание объектов.
Метод помеченный ключевым словом abstract - абстрактный метод, т.е. метод, который не имеет ре-
ализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть 
объявлен абстрактным.
Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который 
должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех 
потомков поведение.
к оглавлению
Дайте определение понятию «интерфейс». Какие модификаторы по умолчанию имеют поля и мето-
ды интерфейсов?
Ключевое слово interface используется для создания полностью абстрактных классов. Основное 
предназначение интерфейса - определять каким образом мы можем использовать класс, который 
его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвра-
щаемых значений, но не реализует их поведение. Все методы неявно объявляются как public.
Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default 
и статических static методов.
Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными 
public, статическими static и неизменяемыми final.
Чем абстрактный класс отличается от интерфейса? 
В каких случаях следует использовать абстрактный 
класс, а в каких интерфейс?
    В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только 
от одного класса.
    Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (явля-
ется). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.
    Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инстру-
мент для частичной реализации поведения. Интерфейс - это средство выражения семантики клас-
са, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как public 
abstract или (начиная с Java 8) default - методами с реализацией по-умолчанию, а поля - public static 
final.
    Интерфейсы позволяют создавать структуры типов без иерархии.


    Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интер-
фейс, он расширяет собственную функциональность.
Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в 
подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от аб-
страктного класса и отличаются лишь в части собственной реализации абстрактных методов роди-
теля. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень 
похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего 
поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания по-
вторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.
Почему в некоторых интерфейсах 
вообще не определяют методов?
Это так называемые маркерные интерфейсы. Они просто указывают что класс относится к опреде-
ленному типу. Примером может послужить интерфейс Clonable, который указывает на то, что класс 
поддерживает механизм клонирования.
Почему нельзя объявить метод 
интерфейса с модификатором final?
В случае интерфейсов указание модификатора final бессмысленно, т.к. все методы интерфейсов 
неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а 
этого нельзя будет сделать, если у метода идентификатор final.
Что имеет более высокий уровень абстракции - класс, 
абстрактный класс или интерфейс?
Интерфейс.
Может ли объект получить доступ к члену класса 
объявленному как private? 
Если да, то каким образом?
    Внутри класса доступ к приватной переменной открыт без ограничений;
    Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего 
его класса;
    Доступ к приватным переменным извне может быть организован через отличные от приватных 
методов, которые предоставлены разработчиком класса. Например: getX() и setX().
    Через механизм рефлексии (Reflection API):
class Victim { 
    private int field = 42;

}

//...
Victim victim = new Victim(); 
Field field = Victim.class.getDeclaredField(«field»); 
field.setAccessible(true); 
int fieldValue = (int) field.get(victim);
//...


Каков порядок вызова конструкторов и блоков инициа-
лизации с учётом иерархии классов?
Сначала вызываются все статические блоки в очередности от первого статического блока корневого 
предка и выше по цепочке иерархии до статических блоков самого класса.
Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого 
предка и так далее вплоть до нестатических блоков и конструктора самого класса.
    Parent static block(s) → Child static block(s) → Grandchild static block(s)
    → Parent non-static block(s) → Parent constructor →
    → Child non-static block(s) → Child constructor →
    → Grandchild non-static block(s) → Grandchild constructor
Пример 1:
public class MainClass {
    public static void main(String args[]) {
        System.out.println(TestClass.v);
        new TestClass().a();
    }

}

public class TestClass {
    public static String v = «Some val»;
    {
        System.out.println(«!!! Non-static initializer»);
    }
    static {
        System.out.println(«!!! Static initializer»);
    }
    public void a() {
        System.out.println(«!!! a() called»);
    }

}

Результат выполнения:
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
Пример 2:


public class MainClass {
    public static void main(String args[]) {        
        new TestClass().a();
    }

}

public class TestClass {
    public static String v = «Some val»;
    {
        System.out.println(«!!! Non-static initializer»);
    }
    static {
        System.out.println(«!!! Static initializer»);
    }
    public void a() {
        System.out.println(«!!! a() called»);
    }

}

Результат выполнения:
!!! Static initializer
!!! Non-static initializer
!!! a() called
Зачем нужны и какие бывают блоки инициализации?
Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый 
внутри класса вне объявления методов или конструкторов.
    Существуют статические и нестатические блоки инициализации.
    Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созда-
нием объекта класса с помощью конструктора.
    Несколько блоков инициализации выполняются в порядке следования в коде класса.
    Блок инициализации способен генерировать исключения, если их объявления перечислены в 
throws всех конструкторов класса.
    Блок инициализации возможно создать и в анонимном классе.
К каким конструкциям Java применим модификатор 
static?
    - полям;
    - методам;
    - вложенным классам;
    - членам секции import.
Для чего в Java используются статические 
блоки инициализации?


Статические блоки инициализация используются для выполнения кода, который должен выпол-
няться один раз при инициализации класса загрузчиком классов, в момент, предшествующий соз-
данию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, 
принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту мета-
класса Class).
Что произойдёт, если в блоке инициализации возникнет 
исключительная ситуация?
Для нестатических блоков инициализации, если выбрасывание исключения прописано явным 
образом требуется, чтобы объявления этих исключений были перечислены в throws всех конструк-
торов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения 
в явном виде, приводит к ошибке компиляции.
В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом дру-
гом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект 
класса не будет создан, если ошибка возникает в нестатическом блоке.
Какое исключение выбрасывается при возникновении 
ошибки в блоке инициализации класса?
Если возникшее исключение - наследник RuntimeException:
    - для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
    - для нестатических будет проброшено исключение-источник.
Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error. 
Исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено 
не будет.
Может ли статический метод быть 
переопределён или перегружен?
Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода 
могут иметь одинаковое имя, если количество их параметров или типов различается.
Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании 
(на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя син-
таксически переопределение статического метода - это вполне корректная языковая конструкция.
В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.
Могут ли нестатические методы перегрузить 
статические?
Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен 
через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов 
метода этого объекта.
Можно ли сузить уровень доступа, тип возвращаемого 
значения при переопределении метода?


Возможно ли при переопределении метода изменить: 
модификатор доступа, возвращаемый тип, 
тип аргумента или их количество, имена аргументов или 
их порядок; убирать, добавлять, изменять порядок 
следования элементов секции throws?
При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к на-
рушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.
Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеет-
ся в виду:
    Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону 
сужения типа (вместо родительского класса - наследника).
    При изменении типа, количества, порядка следования аргументов вместо переопределения будет 
происходить overloading (перегрузка) метода.
    Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, 
если уже определена у метода родительского класса. Так же, возможно добавлять новые исключе-
ния, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок 
следования таких элементов при переопределении значения не имеет.
Как получить доступ к переопределенным методам 
 родительского класса?
С помощью ключевого слова super мы можем обратиться к любому члену родительского класса - 
методу или полю, если они не определены с модификатором private.
super.method();
Можно ли объявить метод абстрактным и статическим 
одновременно?
Нет. В таком случае компилятор выдаст ошибку: «Illegal combination of modifiers: ‘abstract’ and 
‘static’». Модификатор abstract говорит, что метод будет реализован в другом классе, а static наобо-
рот указывает, что этот метод будет доступен по имени класса.
В чем разница между членом экземпляра класса и стати-
ческим членом класса?
Модификатор static говорит о том, что данный метод или поле принадлежат самому классу и доступ 
к ним возможен даже без создания экземпляра класса. Поля, помеченные static инициализируются 
при инициализации класса. На методы, объявленные как static, накладывается ряд ограничений:
    Они могут вызывать только другие статические методы.
    Они должны осуществлять доступ только к статическим переменным.
    Они не могут ссылаться на члены типа this или super.
В отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут 
иметь разные значения для каждого. Вызов метода экземпляра возможен только после предвари-
тельного создания объекта класса.


Пример:
public class MainClass {
 public static void main(String args[]) {
 System.out.println(TestClass.v);
 new TestClass().a();
 System.out.println(TestClass.v);
 }

}

public class TestClass {
 public static String v = «Initial val»;
 {
 System.out.println(«!!! Non-static initializer»);
 v = «Val from non-static»;
 }
 static {
 System.out.println(«!!! Static initializer»);
 v = «Some val»;
 }
 public void a() {
 System.out.println(«!!! a() called»);
 }

}

Результат:
!!! Static initializer
Some val
!!! Non-static initializer
!!! a() called
Val from non-static

Где разрешена инициализация 
статических/нестатических полей?
    Статические поля можно инициализировать при объявлении, в статическом или нестатическом 
блоке инициализации.
    Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициа-
лизации или в конструкторе.
Какие типы классов бывают в java?
    - Top level class (Обычный класс):
        Abstract class (Абстрактный класс);
        Final class (Финализированный класс).
    - Interfaces (Интерфейс).


    - Enum (Перечисление).
    - Nested class (Вложенный класс):
        Static nested class (Статический вложенный класс);
        Member inner class (Простой внутренний класс);
        Local inner class (Локальный класс);
        Anonymous inner class (Анонимный класс).
Расскажите про вложенные классы. 
В каких случаях они применяются?
Класс называется вложенным (Nested class), если он определен внутри другого класса. Вложенный 
класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. Если вло-
женный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего 
уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внеш-
него класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к 
некоторому нарушению инкапсуляции.
Существуют четыре категории вложенных классов: + Static nested class (Статический вложенный 
класс); + Member inner class (Простой внутренний класс); + Local inner class (Локальный класс); + 
Anonymous inner class (Анонимный класс).
Такие категории классов, за исключением первого, также называют внутренними (Inner class). Вну-
тренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.
Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен 
быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было 
удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима 
ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае, 
если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. Если 
класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса 
только в этом методе, то используется локальный класс. А, если к тому же применение класса сво-
дится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс, то 
рекомендуется делать его анонимным классом.
Что такое «статический класс»?
Это вложенный класс, объявленный с использованием ключевого слова static. К классам верхнего 
уровня модификатор static неприменим.
Какие существуют особенности использования вложен-
ных классов: статических и внутренних? 
В чем заключается разница между ними?
    Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и при-
ватным.
    Для создания объекта статического вложенного класса объект внешнего класса не требуется.
    Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрам-
ляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.
    Обычные вложенные классы не могут содержать статических методов, блоков инициализации и 
классов. Статические вложенные классы - могут.
    В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри 
статической такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через 
указание .this после его имени. Например: Outer.this.


Что такое «локальный класс»? Каковы его особенности?
Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован в 
любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние клас-
сы (Member inner class) локальные классы имеют имена и могут использоваться многократно. Как 
и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в 
нестатическом контексте.
Локальные классы имеют следующие особенности:
    - Видны только в пределах блока, в котором объявлены;
    - Не могут быть объявлены как private/public/protected или static;
    - Не могут иметь внутри себя статических объявлений методов и классов, но могут иметь фи-
нальные статические поля, проинициализированные константой;
    - Имеют доступ к полям и методам обрамляющего класса;
    - Могут обращаться к локальным переменным и параметрам метода, если они объявлены с моди-
фикатором final.
Что такое «анонимные классы»? Где они применяются?
Это вложенный локальный класс без имени, который разрешено декларировать в любом месте 
обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного 
класса происходит одновременно с его объявлением. В зависимости от местоположения аноним-
ный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом 
контексте появляется окружающий его экземпляр.
Анонимные классы имеют несколько ограничений:
    - Их использование разрешено только в одном месте программы - месте его создания;
    - Применение возможно только в том случае, если после порождения экземпляра нет необходи-
мости на него ссылаться;
    - Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо 
новых методов, так как для доступа к ним нет поименованного типа.
Анонимные классы обычно применяются для:
    - создания объекта функции (function object), например, реализация интерфейса Comparator;
    - создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и 
подобных;
    - в статическом методе генерации;
    - инициализации открытого статического поля final, которое соответствует сложному перечисле-
нию типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.
Каким образом из вложенного класса получить доступ 
к полю внешнего класса?
Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего 
класса.
Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, 
если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю 
следует через ссылку на его экземляр. Например: Outer.this.field.


Для чего используется оператор assert?
Assert (Утверждение) — это специальная конструкция, позволяющая проверять предположения о 
значениях произвольных данных в произвольном месте программы. Утверждение может автомати-
чески сигнализировать об обнаружении некорректных данных, что обычно приводит к аварийному 
завершению программы с указанием места обнаружения некорректных данных.
Утверждения существенно упрощают локализацию ошибок в коде. Даже проверка результатов вы-
полнения очевидного кода может оказаться полезной при последующем рефакторинге, после кото-
рого код может стать не настолько очевидным и в него может закрасться ошибка.
Обычно утверждения оставляют включенными во время разработки и тестирования программ, но 
отключают в релиз-версиях программ.
Т.к. утверждения могут быть удалены на этапе компиляции либо во время исполнения программы, 
они не должны менять поведение программы. Если в результате удаления утверждения поведение 
программы может измениться, то это явный признак неправильного использования assert. Таким 
образом, внутри assert нельзя вызывать методы, изменяющие состояние программы, либо внешнего 
окружения программы.
В Java проверка утверждений реализована с помощью оператора assert, который имеет форму:
assert [Выражение типа boolean]; или assert [Выражение типа boolean] : [Выражение любого типа, 
кроме void];
Во время выполнения программы в том случае, если поверка утверждений включена, вычисляется 
значение булевского выражения, и если его результат false, то генерируется исключение java.lang.
AssertionError. В случае использования второй формы оператора assert выражение после двоеточия 
задаёт детальное сообщение о произошедшей ошибке (вычисленное выражение будет преобразова-
но в строку и передано конструктору AssertionError).
Что такое Heap и Stack память в Java? 
Какая разница между ними?
Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание но-
вого объекта также происходит в куче. Это же является областью работы сборщика мусора. Лю-
бой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части 
приложения.
Stack (стек) это область хранения данных также находящееся в общей оперативной памяти (RAM). 
Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит при-
митивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также пе-
рестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой 
памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO (Последний-за-
шел-Первый-вышел)
Различия между Heap и Stack памятью:
    Куча используется всеми частями приложения в то время как стек используется только одним 
потоком исполнения программы.
    Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь 
ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссыл-
ки на объекты в куче.


    Объекты в куче доступны с любой точки программы, в то время как стековая память не может 
быть доступна для других потоков.
    Стековая память существует лишь какое-то время работы программы, а память в куче живет с 
самого начала до конца работы программы.
    Если память стека полностью занята, то Java Runtime бросает исключение java.lang.
StackOverflowError. Если заполнена память кучи, то бросается исключение java.lang.
OutOfMemoryError: Java Heap Space.
    Размер памяти стека намного меньше памяти в куче.
    Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.
Для определения начального и максимального размера памяти в куче используются -Xms и -Xmx 
опции JVM. Для стека определить размер памяти можно с помощью опции -Xss.
Верно ли утверждение, что примитивные типы данных 
всегда хранятся в стеке, а экземпляры ссылочных типов 
данных в куче?
Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, 
что явно или неявно создаётся при помощи оператора new) хранится в куче.
Каким образом передаются переменные в методы, 
по значению или по ссылке?
В Java параметры всегда передаются только по значению, что определяется как «скопировать значе-
ние и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия 
содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию 
изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.
Для чего нужен сборщик мусора?
Сборщик мусора (Garbage Collector) должен делать всего две вещи:
    Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из 
сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссы-
лок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
    Освобождать память от мусора.
Существует два подхода к обнаружению мусора:
    - Reference counting;
    - Tracing
Reference counting (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет 
счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка 
уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать 
мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. 
Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают 
друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.
Главная идея подхода Tracing (трассировка) состоит в утверждении, что живыми могут считаться 
только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те объекты, 
которые доступны с живого объекта. Всё остальное - мусор.


Существует 4 типа корневых точки:
    - Локальные переменные и параметры методов;
    - Потоки;
    - Статические переменные;
    - Ссылки из JNI.
Самое простое java приложение будет иметь корневые точки:
    - Локальные переменные внутри main() метода и параметры main() метода;
    - Поток который выполняет main();
    - Статические переменные класса, внутри которого находится main() метод.
Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нуж-
но будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем 
добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко 
выявляются. HotSpot VM использует именно такой подход.
Для очистки памяти от мусора существуют два основных метода:
    - Copying collectors
    - Mark-and-sweep
При copying collectors подходе память делится на две части «from-space» и «to-space», при этом сам 
принцип работы такой:
    Объекты создаются в «from-space»;
    Когда «from-space» заполняется, приложение приостанавливается;
    Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-
space»;
    Когда все объекты скопированы «from-space» полностью очищается;
    «to-space» и «from-space» меняются местами.
Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:
    Приложение должно быть остановлено на время, необходимое для полного прохождения цикла 
сборки мусора;
    В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одина-
кового размера.
Алгоритм работы mark-and-sweep можно описать так:
    - Объекты создаются в памяти;
    - В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
    - Сборщик проходится по дереву объектов, помечая живые объекты;
    - Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в 
«free list»;
    - Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».
Минусы этого способа:
    - Приложение не работает пока происходит сборка мусора;
    - Время остановки напрямую зависит от размеров памяти и количества объектов;
    - Если не использовать «compacting» память будет использоваться не эффективно.


Сборщики мусора HotSpot VM используют комбинированный подход Generational Garbage 
Collection, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. 
Этот подход опирается на том, что:
    - большинство создаваемых объектов быстро становятся мусором;
    - существует мало связей между объектами, которые были созданы в прошлом и только что соз-
данными объектами.
Как работает сборщик мусора?
Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления 
новых объектов.
Объекты создаются посредством оператора new, тем самым присваивая объекту ссылку. Для окон-
чания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив 
переменной ссылку на другой объект или значение null; прекратить выполнение метода, чтобы его 
локальные переменные завершили свое существование естественным образом. Объекты, ссылки на 
которые отсутствуют, принято называть мусором (garbage), который будет удален.
Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, 
обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого 
кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. 
Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим 
посредством цепочки ссылок, начиная с корневой (GC Root) ссылки, т.е. ссылки, непосредственно 
существующей в выполняемом коде.
Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может 
успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к 
этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.
Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но 
это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления 
большого количества объектов существенным образом сказывается на производительности прило-
жений и если быстродействие программы является важным фактором, следует тщательно обдумы-
вать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, 
подлежащего утилизации.
Какие разновидности сборщиков мусора реализованы в 
виртуальной машине HotSpot?
Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:
    Serial (последовательный) — самый простой вариант для приложений с небольшим объемом 
данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но 
на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолча-
нию. Использование Serial GC включается опцией -XX:+UseSerialGC.
    Parallel (параллельный) — наследует подходы к сборке от последовательного сборщика, но до-
бавляет параллелизм в некоторые операции, а также возможности по автоматической подстрой-
ке под требуемые параметры производительности. Параллельный сборщик включается опцией 
-XX:+UseParallelGC.
    Concurrent Mark Sweep (CMS) — нацелен на снижение максимальных задержек путем выполне-
ния части работ по сборке мусора параллельно с основными потоками приложения. Подходит для 
работы с относительно большими объемами данных в памяти. Использование CMS GC включается 


опцией -XX:+UseConcMarkSweepGC.
    Garbage-First (G1) — создан для замены CMS, особенно в серверных приложениях, работающих 
на многопроцессорных серверах и оперирующих большими объемами данных. G1 включается оп-
цией Java -XX:+UseG1GC.
Опишите алгоритм работы какого-нибудь сборщика 
мусора, реализованного в виртуальной машине HotSpot.
Serial Garbage Collector (Последовательный сборщик мусора) был одним из первых сборщиков му-
сора в HotSpot VM. Во время работы этого сборщика приложения приостанавливается и продолжа-
ет работать только после прекращения сборки мусора.
Память приложения делится на три пространства:
    - Young generation. Объекты создаются именно в этом участке памяти.
    - Old generation. В этот участок памяти перемещаются объекты, которые переживают «minor 
garbage collection».
    - Permanent generation. Тут хранятся метаданные об объектах, Class data sharing (CDS), пул строк 
(String pool). Permanent область делится на две: только для чтения и для чтения-записи. Очевидно, 
что в этом случае область только для чтения не чистится сборщиком мусора никогда.
Область памяти Young generation состоит из трёх областей: Eden и двух меньших по размеру 
Survivor spaces - To space и From space. Большинство объектов создаются в области Eden, за исклю-
чением очень больших объектов, которые не могут быть размещены в ней и поэтому сразу разме-
щаются в Old generation. В Survivor spaces перемещаются объекты, которые пережили по крайней 
мере одну сборку мусора, но ещё не достигли порога «старости» (tenuring threshold), чтобы быть 
перемещенными в Old generation.
Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (minor 
collection), в отличие от процесса сборки, проводимого над всей кучей (full collection). Он проис-
ходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а 
другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет 
живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то 
есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты 
из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются 
ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.
Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объ-
екты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, 
независимо от того, сколько сборок мусора они пережили.
Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объ-
екты из одной области памяти в другую, то такой сборщик мусора называется copying (копирую-
щий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть 
свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может 
применяться для областей памяти сравнительно небольших по отношению к общему размеру памя-
ти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах 
клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимо-
сти от платформы)).
Однако, для сборки мусора в Old generation, занимающем большую часть всей памяти, используется 
другой алгоритм.
В Old generation сборка мусора происходит с использованием алгоритма mark-sweep-compact, ко-


торый состоит из трёх фаз. В фазе Mark (пометка) сборщик мусора помечает все живые объекты, 
затем, в фазе Sweep (очистка) все не помеченные объекты удаляются, а в фазе Сompact (уплотне-
ние) все живые объекты перемещаются в начало Old generation, в результате чего свободная память 
после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, 
чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.
Когда свободная память представляет собой непрерывную область, то для выделения памяти под 
создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) 
алгоритм bump-the-pointer: адрес начала свободной памяти хранится в специальном указателе, и 
когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта доста-
точно места, и, если это так, то просто увеличивает указатель на размер объекта.
Последовательный сборщик мусора отлично подходит для большинства приложений, использую-
щих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких 
требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-
world» может вызвать длительные паузы в работе приложения при использовании больших объ-
ёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально исполь-
зовать вычислительные ресурсы компьютера, и последовательный сборщик мусора может стать 
узким местом при работе приложения на многопроцессорных машинах.
Что такое «пул строк»?
Пул строк – это набор строк, хранящийся в Heap.
    Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования 
строк;
    Пул строк помогает экономить память, но по этой же причине создание строки занимает больше 
времени;
    Когда для создания строки используются «, то сначала ищется строка в пуле с таким же значени-
ем, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем 
возвращается ссылка на неё;
    При использовании оператора new создаётся новый объект String. Затем при помощи метода 
intern() эту строку можно поместить в пул или же получить из пула ссылку на другой объект String 
с таким же значением;
    Пул строк является примером паттерна «Приспособленец» (Flyweight).
Что такое finalize()? Зачем он нужен?
Через вызов метода finalize() (который наследуется от Java.lang.Object) JVM реализуется функцио-
нальность аналогичная функциональности деструкторов в С++, используемых для очистки памяти 
перед возвращением управления операционной системе. Данный метод вызывается при уничтоже-
нии объекта сборщиком мусора (garbage collector) и переопределяя finalize() можно запрограмми-
ровать действия необходимые для корректного удаления экземпляра класса - например, закрытие 
сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д.
После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это 
считается серьезной проблемой метода finalize() т.к. он мешает сборщику мусора освобождать 
память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как 
будет запущена сборка мусора.
Объект не обязательно будет доступен для сборки сразу же - метод finalize() может сохранить ку-
да-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается 
антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.


Пример:
public class MainClass {

 

public static void main(String args[]) {

 

 TestClass a = new TestClass();

 

 a.a();

 

 a = null;

 

 a = new TestClass();

 

 a.a();

 

 System.out.println(«!!! done»);

 

}

}

public class TestClass {
 public void a() {
 System.out.println(«!!! a() called»);
 }

 

@Override

 

protected void finalize() throws Throwable {

 

 System.out.println(«!!! finalize() called»);

 

 super.finalize();

 

}

}

Так как в данном случае сборщик мусора может и не быть вызван (в силу простоты приложения), 
то результат выполнения программы с большой вероятностью будет следующий:
!!! a() called
!!! a() called
!!! done
Теперь несколько усложним программу, добавив принудительный вызов Garbage Collector:
public class MainClass {
 public static void main(String args[]) {
 TestClass a = new TestClass();
 a.a();
 a = null;
 System.gc(); // Принудительно зовём сборщик мусора
 a = new TestClass();
 a.a();
 System.out.println(«!!! done»);
 }

}

Как и было сказано ранее, Garbage Collector может в разное время отработать, поэтому результат 
выполнения может разниться от запуска к запуску: Вариант а:
!!! a() called
!!! a() called
!!! done


!!! finalize() called
Вариант б:
!!! a() called
!!! a() called
!!! finalize() called
!!! done
Что произойдет со сборщиком мусора, если выполнение 
метода finalize() требует ощутимо много времени, или в 
процессе выполнения будет выброшено исключение?
Непосредственно вызов finalize() происходит в отдельном потоке Finalizer (java.lang.ref.Finalizer.
FinalizerThread), который создаётся при запуске виртуальной машины (в статической секции при 
загрузке класса Finalizer). Методы finalize() вызываются последовательно в том порядке, в котором 
были добавлены в список сборщиком мусора. Соответственно, если какой-то finalize() зависнет, он 
подвесит поток Finalizer, но не сборщик мусора. Это в частности означает, что объекты, не имеющие 
метода finalize(), будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока поток 
Finalizer не освободится, не завершится приложение или не кончится память.
То же самое применимо и выброшенным в процессе finalize() исключениям: метод runFinalizer() у 
потока Finalizer игнорирует все исключения выброшенные в момент выполнения finalize(). Таким 
образом возникновение исключительной ситуации никак не скажется на работоспособности сбор-
щика мусора.
Чем отличаются final, finally и finalize()?
Модификатор final:
    - Класс не может иметь наследников;
    - Метод не может быть переопределен в классах наследниках;
    - Поле не может изменить свое значение после инициализации;
    - Локальные переменные не могут быть изменены после присвоения им значения;
    - Параметры методов не могут изменять своё значение внутри метода.
Оператор finally гарантирует, что определенный в нём участок кода будет выполнен независимо от 
того, какие исключения были возбуждены и перехвачены в блоке try-catch.
Метод finalize() вызывается перед тем как сборщик мусора будет проводить удаление объекта.
Пример:
public class MainClass {
 public static void main(String args[]) {
 TestClass a = new TestClass();
 System.out.println(«result of a.a() is « + a.a());
 a = null;
 System.gc(); // Принудительно зовём сборщик мусора
 a = new TestClass();
 System.out.println(«result of a.a() is « + a.a());


 System.out.println(«!!! done»);
 }

}

public class TestClass {
 public int a() {
 try {
 System.out.println(«!!! a() called»);
 throw new Exception(«»);
 } catch (Exception e) {
 System.out.println(«!!! Exception in a()»);
 return 2;
 } finally {
 System.out.println(«!!! finally in a() «);
 }
 }
 @Override
 protected void finalize() throws Throwable {
 System.out.println(«!!! finalize() called»);
 super.finalize();
 }

}

Результат выполнения:
!!! a() called
!!! Exception in a()
!!! finally in a() 
result of a.a() is 2
!!! a() called
!!! Exception in a()
!!! finally in a() 
!!! finalize() called
result of a.a() is 2
!!! done
Расскажите про приведение типов. 
Что такое понижение и повышение типа?
Java является строго типизированным языком программирования, а это означает, то что каждое вы-
ражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако 
определен механизм приведения типов (casting) - способ преобразования значения переменной 
одного типа в значение другого типа.
В Java существуют несколько разновидностей приведения:
    Тождественное (identity). Преобразование выражения любого типа к точно такому же типу всегда 
допустимо и происходит автоматически.
    Расширение (повышение, upcasting) примитивного типа (widening primitive). Означает, что осу-
ществляется переход от менее емкого типа к более ёмкому. Например, от типа byte (длина 1 байт) 
к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда 


гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не 
происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.
    Сужение (понижение, downcasting) примитивного типа (narrowing primitive). Означает, что пе-
реход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск 
потерять данные. Например, если число типа int было больше 127, то при приведении его к byte 
значения битов старше восьмого будут потеряны. В Java такое преобразование должно совершаться 
явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются 
- никакого округления или других действий для получения более корректного результата не произ-
водится.
    Расширение объектного типа (widening reference). Означает неявное восходящее приведение ти-
пов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. 
Разрешено всегда и происходит автоматически.
    Сужение объектного типа (narrowing reference). Означает нисходящее приведение, то есть приве-
дение от предка к потомку (подтипу). Возможно только если исходная переменная является подти-
пом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключе-
ние ClassCastException. Требует явного указания типа.
    Преобразование к строке (to String). Любой тип может быть приведен к строке, т.е. к экземпляру 
класса String.
    Запрещенные преобразования (forbidden). Не все приведения между произвольными типами 
допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылоч-
ного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того, невозможно 
привести друг к другу классы, находящиеся на разных ветвях дерева наследования и т.п.
При приведении ссылочных типов с самим объектом ничего не происходит, - меняется лишь тип 
ссылки, через которую происходит обращение к объекту.
Для проверки возможности приведения нужно воспользоваться оператором instanceof:
Parent parent = new Child();
if (parent instanceof Child) {
    Child child = (Child) parent;

}

Когда в приложении может быть 
выброшено исключение ClassCastException?
ClassCastException (потомок RuntimeException) - исключение, которое будет выброшено при ошиб-
ке приведения типа.
Что такое autoboxing («автоупаковка») в Java и каковы 
правила упаковки примитивных типов 
в классы-обертки?
Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short, 
Integer, Long, Float, Double, Character, Boolean) значениями соответствующих им исходных прими-
тивных типов (byte, short, int...), без явного использования конструктора класса.
  Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью опе-
ратора =), либо при передаче примитива в параметры метода (типа класса-обертки).
    Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, 
так и константы времени компиляции (литералы и final-примитивы). При этом литералы должны 
быть синтаксически корректными для инициализации переменной исходного примитивного типа.


    Автоупаковка переменных примитивных типов требует точного соответствия типа исходного 
примитива типу класса-обертки. Например, попытка упаковать переменную типа byte в Short, без 
предварительного явного приведения byte в short вызовет ошибку компиляции.
    Автоупаковка констант примитивных типов допускает более широкие границы соответствия. 
В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение 
типа примитивов:
        неявное расширение/сужение исходного типа примитива до типа примитива соответствующего 
классу-обертке (для преобразования int в Byte, сначала компилятор самостоятельно неявно сужает 
int к byte)
        автоупаковку примитива в соответствующий класс-обертку. Однако, в этом случае существуют 
два дополнительных ограничения: a) присвоение примитива обертке может производится только 
оператором = (нельзя передать такой примитив в параметры метода без явного приведения типов) 
b) тип левого операнда не должен быть старше чем Character, тип правого не дожен старше, чем int: 
допустимо расширение/сужение byte в/из short, byte в/из char, short в/из char и только сужение byte 
из int, short из int, char из int. Все остальные варианты требуют явного приведения типов).
Дополнительной особенностью целочисленных классов-оберток, созданных автоупаковкой кон-
стант в диапазоне -128 ... +127 я вляется то, что они кэшируются JVM. Поэтому такие обертки с 
одинаковыми значениями будут являться ссылками на один объект.
Какие есть особенности класса String?
    Это неизменяемый (immutable) и финализированный тип данных;
    Все объекты класса String JVM хранит в пуле строк;
    Объект класса String можно получить, используя двойные кавычки;
    Можно использовать оператор + для конкатенации строк;
    Начиная с Java 7 строки можно использовать в конструкции switch.
Почему String неизменяемый и финализированный 
класс?
Есть несколько преимуществ в неизменности строк:
    Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная маши-
на сохраняет больше свободного места в Heap, поскольку разные строковые переменные указывают 
на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не 
было бы возможным, потому что изменение значения одной переменной отразилось бы также и на 
остальных переменных, ссылающихся на эту строку.
    Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. 
Например, имя пользователя базы данных и пароль передаются строкой для получения соединения 
с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так 
как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышлен-
ник может изменить значение ссылки и вызвать проблемы в безопасности приложения.
    Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и 
один экземпляр строки может быть совместно использован различными потоками.
    Строки используются classloader и неизменность обеспечивает правильность загрузки класса.
    Поскольку строка неизменяемая, её hashCode() кэшируется в момент создания и нет необходимо-
сти рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap т.к. его 
обработка происходит быстрее.
Почему char[] предпочтительнее String 


для хранения пароля?
С момента создания строка остаётся в пуле, до тех пор, пока не будет удалена сборщиком мусора. 
Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться 
доступным в памяти и способа избежать этого не существует. Это представляет определённый риск 
для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде тек-
ста. В случае использования массива символов для хранения пароля имеется возможность очистить 
его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного 
строке.
Почему строка является популярным ключом 
в HashMap в Java?
Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не тре-
буя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа HashMap они 
будут обрабатываться быстрее.
Что делает метод intern() в классе String?
Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая 
строка уже находится в пуле.
Можно ли использовать строки в конструкции switch?
Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддер-
живают этого. При этом:
    участвующие строки чувствительны к регистру;
    используется метод equals() для сравнения полученного значения со значениями case, поэтому во 
избежание NullPointerException стоит предусмотреть проверку на null.
    согласно документации, Java 7 для строк в switch, компилятор Java формирует более эффектив-
ный байткод для строк в конструкции switch, чем для сцепленных условий if-else.
Какая основная разница между String, StringBuffer, 
StringBuilder?
Класс String является неизменяемым (immutable) - модифицировать объект такого класса нельзя, 
можно лишь заменить его созданием нового экземпляра.
Класс StringBuffer изменяемый - использовать StringBuffer следует тогда, когда необходимо часто 
модифицировать содержимое.
Класс StringBuilder был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением 
того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.
Что такое класс Object? Какие в нем есть методы?
Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, 
соответственно, наследуют его методы:
public boolean equals(Object obj) – служит для сравнения объектов по значению; int hashCode() – 
возвращает hash код для объекта; String toString() – возвращает строковое представление объекта; 
Class getClass() – возвращает класс объекта во время выполнения; protected Object clone() – соз-


дает и возвращает копию объекта; void notify() – возобновляет поток, ожидающий монитор; void 
notifyAll() – возобновляет все потоки, ожидающие монитор; void wait() – остановка вызвавшего 
метод потока до момента пока другой поток не вызовет метод notify() или notifyAll() для этого 
объекта; void wait(long timeout) – остановка вызвавшего метод потока на определённое время или 
пока другой поток не вызовет метод notify() или notifyAll() для этого объекта; void wait(long timeout, 
int nanos) – остановка вызвавшего метод потока на определённое время или пока другой поток не 
вызовет метод notify() или notifyAll() для этого объекта; protected void finalize() – может вызываться 
сборщиком мусора в момент удаления объекта при сборке мусора.
Дайте определение понятию «конструктор».
Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который име-
ет то же имя, что и класс, в котором он используется. Конструктор вызывается при создании нового 
объекта класса и определяет действия необходимые для его инициализации.
Что такое «конструктор по умолчанию»?
Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без 
аргументов - так называемый «конструктор по умолчанию».
public class ClassName() {}
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не бу-
дет и, если он необходим, его нужно описывать явно.
Чем отличаются конструктор по умолчанию, конструктор 
копирования и конструктор с параметрами?
У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования 
принимает в качестве аргумента уже существующий объект класса для последующего создания его 
клона. Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для 
инициализации полей класса).
Где и как вы можете использовать приватный 
конструктор?
Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться 
публичным статическим методом генерации объектов данного класса. Также доступ к нему разре-
шён вложенным классам и может использоваться для их нужд.
Расскажите про классы-загрузчики и про динамическую 
загрузку классов.
Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие 
интерфейс для поиска и создания объекта класса по его имени во время работы приложения.
В начале работы программы создается 3 основных загрузчика классов:
    - базовый загрузчик (bootstrap/primordial). Загружает основные системные и внутренние классы 
JDK (Core API - пакеты java.* (rt.jar и i18n.jar) . Важно заметить, что базовый загрузчик является 
«Изначальным» или «Корневым» и частью JVM, вследствие чего его нельзя создать внутри кода 
программы.
    - загрузчик расширений (extention). Загружает различные пакеты расширений, которые распола-


гаются в директории <JAVA_HOME>/lib/ext или другой директории, описанной в системном па-
раметре java.ext.dirs. Это позволяет обновлять и добавлять новые расширения без необходимости 
модифицировать настройки используемых приложений. Загрузчик расширений реализован клас-
сом sun.misc.Launcher$ExtClassLoader.
    - системный загрузчик (system/application). Загружает классы, пути к которым указаны в 
переменной окружения CLASSPATH или пути, которые указаны в командной строке запу-
ска JVM после ключей -classpath или -cp. Системный загрузчик реализован классом sun.misc.
Launcher$AppClassLoader.
Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родитель-
ский загрузчик и в большинстве случаев, перед тем как попробовать загрузить класс самостоятель-
но, он посылает вначале запрос родительскому загрузчику загрузить указанный класс. Такое делеги-
рование позволяет загружать классы тем загрузчиком, который находится ближе всего к базовому 
в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке 
их доверия: сначала в библиотеке Core API, потом в папке расширений, потом в локальных файлах 
CLASSPATH.
Процесс загрузки класса состоит из трех частей:
   - Loading – на этой фазе происходит поиск и физическая загрузка файла класса в определенном 
источнике (в зависимости от загрузчика). Этот процесс определяет базовое представление класса в 
памяти. На этом этапе такие понятия как «методы», «поля» и т.д. пока не известны.
   - Linking – процесс, который может быть разбит на 3 части:
        Bytecode verification – проверка байт-кода на соответствие требованиям, определенным в спец-
ификации JVM.
        Class preparation – создание и инициализация необходимых структур, используемых для пред-
ставления полей, методов, реализованных интерфейсов и т.п., определенных в загружаемом классе.
        Resolving – загрузка набора классов, на которые ссылается загружаемый класс.
   - Initialization – вызов статических блоков инициализации и присваивание полям класса значений 
по умолчанию.
Динамическая загрузка классов в Java имеет ряд особенностей:
    - отложенная (lazy) загрузка и связывание классов. Загрузка классов производится только при 
необходимости, что позволяет экономить ресурсы и распределять нагрузку.
    - проверка корректности загружаемого кода (type safeness). Все действия связанные с контролем 
использования типов производятся только во время загрузки класса, позволяя избежать дополни-
тельной нагрузки во время выполнения кода.
    - программируемая загрузка. Пользовательский загрузчик полностью контролирует процесс 
получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать 
создание другому загрузчику. Дополнительно существует возможность выставлять различные атри-
буты безопасности для загружаемых классов, позволяя таким образом работать с кодом из нена-
дежных источников.
    - множественные пространства имен. Каждый загрузчик имеет своё пространство имён для 
создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на 
основе общего байт-кода, в системе будут различаться.
Существует несколько способов инициировать загрузку требуемого класса:
    - явный: вызов ClassLoader.loadClass() или Class.forName() (по умолчанию используется загрузчик, 
создавший текущий класс, но есть возможность и явного указания загрузчика);
    - неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, 
JVM инициирует его загрузку.


Что такое Reflection?
Рефлексия (Reflection) - это механизм получения данных о программе во время её выполнения 
(runtime). В Java Reflection осуществляется с помощью Java Reflection API, состоящего из классов 
пакетов java.lang и java.lang.reflect.
Возможности Java Reflection API:
    Определение класса объекта;
    Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;
    Определение интерфейсов, реализуемых классом;
    Создание экземпляра класса;
    Получение и установка значений полей объекта;
    Вызов методов объекта;
    Создание нового массива.
Зачем нужен equals(). 
Чем он отличается от операции ==?
Метод equals() - определяет отношение эквивалентности объектов.
При сравнении объектов с помощью == сравнение происходит лишь между ссылками. При сравне-
нии по переопределённому разработчиком equals() - по внутреннему состоянию объектов.
Если вы хотите переопределить equals(), какие условия 
должны выполняться? Какими свойствами обладает 
порождаемое equals() отношение эквивалентности?
    Рефлексивность: для любой ссылки на значение x, x.equals(x) вернет true;
    Симметричность: для любых ссылок на значения x и y, x.equals(y) должно вернуть true, тогда и 
только тогда, когда y.equals(x) возвращает true.
    Транзитивность: для любых ссылок на значения x, y и z, если x.equals(y) и y.equals(z) возвращают 
true, тогда и x.equals(z) вернёт true;
    Непротиворечивость: для любых ссылок на значения х и у, если несколько раз вызвать х.equals(y), 
постоянно будет возвращаться значение true либо постоянно будет возвращаться значение false при 
условии, что никакая информация, используемая при сравнении объектов, не поменялась.
Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.
Правила переопределения метода Object.equals().
    Использование оператора == для проверки, является ли аргумент ссылкой на указанный объект. 
Если является, возвращается true. Если сравниваемый объект == null, должно вернуться false.
    Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли аргумент 
правильный тип. Если не имеет, возвращается false.
    Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой 
instanceof она гарантированно будет выполнена.
    Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и зна-
чение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу. Если 
проверки для всех полей прошли успешно, возвращается результат true, в противном случае - false.
По окончанию переопределения метода equals() следует проверить: является ли порождаемое отно-
шение эквивалентности рефлексивным, симметричным, транзитивным и непротиворечивым? Если 


ответ отрицательный, метод подлежит соответствующей правке.
Какая связь между hashCode() и equals()?
Если equals() переопределен, есть ли какие-либо другие 
методы, которые следует переопределить?
Равные объекты должны возвращать одинаковые хэш коды. При переопределении equals() нужно 
обязательно переопределять и метод hashCode().
Что будет, если переопределить equals() 
не переопределяя hashCode()? 
Какие могут возникнуть проблемы?
Классы и методы, которые используют правила этого контракта могут работать некорректно. Так 
для HashMap это может привести к тому, что пара «ключ-значение», которая была в неё помещена 
при использовании нового экземпляра ключа не будет в ней найдена.
Каким образом реализованы методы hashCode() и 
equals() в классе Object?
Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:
public boolean equals(Object obj) {
  return (this == obj);

}

Реализация метода Object.hashCode() описана как native, т.е. определенной не с помощью Java кода и 
обычно возвращает адрес объекта в памяти:
public native int hashCode();
Для чего нужен метод hashCode()?
Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра 
объекта. В Java это целое число, в более широком смыле - битовая строка фиксированной длины, 
полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного 
и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java мно-
жество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. 
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:
    - если хэш коды разные, то и объекты гарантированно разные;
    - если хэш коды равны, то объекты могут не обязательно равны.
Каковы правила переопределения 
метода Object.hashCode()?
Есть ли какие-либо рекомендации о том, какие поля 
следует использовать при подсчете hashCode()?
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для это-
го необходимо использовать уникальные, лучше всего примитивные поля, например, такие как id, 
uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то 
они должны быть задействованы и при выполнении equals().


Могут ли у разных объектов быть одинаковые 
hashCode()?
Да, могут. Метод hashCode() не гарантирует уникальность возвращаемого значения. Ситуация, 
когда у разных объектов одинаковые хэш коды называется коллизией. Вероятность возникновения 
коллизии зависит от используемого алгоритма генерации хэш кода.
Если у класса Point{int x, y;} реализовать метод 
equals(Object that) {(return this.x == that.x && this.y == 
that.y)}, но сделать хэш код в виде 
int hashCode() {return x;}, 
то будут ли корректно такие точки 
помещаться и извлекаться из HashSet?
HashSet использует HashMap для хранения элементов. При добавлении элемента в HashMap вычис-
ляется хэш код, по которому определяется позиция в массиве, куда будет вставлен новый элемент. 
У всех экземпляров класса Point хэш код будет одинаковым для всех объектов с одинаковым x, что 
приведёт к вырождению хэш таблицы в список.
При возникновении коллизии в HashMap осуществляется проверка на наличие элемента в списке: 
e.hash == hash && ((k = e.key) == key || key.equals(k)). Если элемент найден, то его значение перезапи-
сывается. В нашем случае для разных объектов метод equals() будет возвращать false. Соответствен-
но новый элемент будет успешно добавлен в HashSet. Извлечение элемента также будет осущест-
вляться успешно. Но производительность такого кода будет невысокой и преимущества хэш таблиц 
использоваться не будут.
Могут ли у разных объектов (ref0 != ref1) быть 
ref0.equals(ref1) == true?
Да, могут. Для этого в классе этих объектов должен быть переопределен метод equals().
Если используется метод Object.equals(), то для двух ссылок x и y метод вернет true тогда и только 
тогда, когда обе ссылки указывают на один и тот же объект (т.е. x == y возвращает true).
Могут ли у разных ссылок на один объект (ref0 == ref1)
быть ref0.equals(ref1) == false?
В общем случае - могут, если метод equals() реализован некорректно и не выполняет свойство реф-
лексивности: для любых ненулевых ссылок x метод x.equals(x) должен возвращать true.
Можно ли так реализовать метод equals(Object that) 
{return this.hashCode() == that.hashCode()}?
Строго говоря нельзя, поскольку метод hashCode() не гарантирует уникальность значения для 
каждого объекта. Однако для сравнения экземпляров класса Object такой код допустим, т.к. метод 
hashCode() в классе Object возвращает уникальные значения для разных объектов (его вычисление 
основано на использовании адреса объекта в памяти).
В equals() требуется проверять, что аргумент 
equals(Object that) такого же типа что и сам объект. 


В чем разница между this.getClass() == that.getClass() и 
that instanceof MyClass?
Оператор instanceof сравнивает объект и указанный тип. Его можно использовать для проверки яв-
ляется ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, 
либо экземпляром класса, который реализует указанный интерфейс.
this.getClass() == that.getClass() проверяет два класса на идентичность, поэтому для корректной ре-
ализации контракта метода equals() необходимо использовать точное сравнение с помощью метода 
getClass().
Можно ли реализовать метод equals() класса MyClass 
вот так: class MyClass {public boolean equals(MyClass 
that) {return this == that;}}?
Реализовать можно, но данный метод не переопределяет метод equals() класса Object, а перегружает 
его.
Есть класс Point{int x, y;}. 
Почему хэш код в виде 31 * x + y предпочтительнее 
чем x + y?
Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге 
порождает лучшую хэш функцию.
Расскажите про клонирование объектов.
Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на 
объект. Таким образом, две ссылки указывают на одну и ту же область памяти, на один и тот же 
объект. Для создания нового объекта с таким же состоянием используется клонирование объекта.
Класс Object содержит protected метод clone(), осуществляющий побитовое копирование объек-
та производного класса. Однако сначала необходимо переопределить метод clone() как public для 
обеспечения возможности его вызова. В переопределенном методе следует вызвать базовую версию 
метода super.clone(), которая и выполняет собственно клонирование.
Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс Cloneable. 
Интерфейс Cloneable не содержит методов относится к маркерным интерфейсам, а его реализа-
ция гарантирует, что метод clone() класса Object возвратит точную копию вызвавшего его объекта 
с воспроизведением значений всех его полей. В противном случае метод генерирует исключение 
CloneNotSupportedException. Следует отметить, что при использовании этого механизма объект 
создается без вызова конструктора.
Это решение эффективно только в случае, если поля клонируемого объекта представляют собой 
значения базовых типов и их обёрток или неизменяемых (immutable) объектных типов. Если же 
поле клонируемого типа является изменяемым ссылочным типом, то для корректного клонирова-
ния требуется другой подход. Причина заключается в том, что при создании копии поля оригинал 
и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клони-
ровать и сам объект поля класса.
Такое клонирование возможно только в случае, если тип атрибута класса также реализует интер-
фейс Cloneable и переопределяет метод clone(). Так как, если это будет иначе вызов метода невозмо-


жен из-за его недоступности. Отсюда следует, что если класс имеет суперкласс, то для реализации 
механизма клонирования текущего класса-потомка необходимо наличие корректной реализации 
такого механизма в суперклассе. При этом следует отказаться от использования объявлений final 
для полей объектных типов по причине невозможности изменения их значений при реализации 
клонирования.
Помимо встроенного механизма клонирования в Java для клонирования объекта можно использо-
вать:
    Специализированный конструктор копирования - в классе описывается конструктор, который 
принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей 
переданного.
    Фабричный метод - (Factory method), который представляет собой статический метод, возвраща-
ющий экземпляр своего класса.
    Механизм сериализации - сохранение и последующее восстановление объекта в/из потока бай-
тов.
В чем отличие между поверхностным и 
глубоким клонированием?
Поверхностное копирование копирует настолько малую часть информации об объекте, насколько 
это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс Object не 
знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по 
следующим правилам:
    Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия 
объекта и возвращена ссылка на этот объект.
    Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда ко-
пируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые 
ссылки.
Глубокое копирование дублирует абсолютно всю информацию объекта:
    Нет необходимости копировать отдельно примитивные данные;
    Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для 
каждого такого члена при переопределении метода clone() должен вызываться super.clone();
    Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необхо-
димо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в 
новый объект класса, по одному.
Какой способ клонирования предпочтительней?
Наиболее безопасным и, следовательно, предпочтительным способом клонирования является ис-
пользование специализированного конструктора копирования:
    Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые 
поля, которые не будут склонированы через метод clone());
    Поля для клонирования указываются явно;
    Возможность клонировать даже final поля.
Почему метод clone() объявлен в классе Object, 
а не в интерфейсе Cloneable?
Метод clone() объявлен в классе Object с указанием модификатора native, чтобы обеспечить доступ 


к стандартному механизму поверхностного копирования объектов. Одновременно он объявлен 
и как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. Не-
посредственно интерфейс Cloneable является маркерным (не содержит объявлений методов) и 
нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть клони-
рованным. Вызов переопределённого метода clone() у не Cloneable объекта вызовет выбрасывание 
CloneNotSupportedException.
Опишите иерархию исключений.
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable, 
потомками которого являются классы Exception и Error.
Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации 
Java, не следует обрабатывать в собственной программе, поскольку они связаны с проблемами уров-
ня JVM. Например, исключения такого рода возникают, если закончилась память доступная вирту-
альной машине.
Исключения (Exceptions) являются результатом проблем в программе, которые в принципе реша-
емы, предсказуемы и последствия которых возможно устранить внутри программы. Например, 
произошло деление целого числа на ноль.
Какие виды исключений в Java вы знаете, 
чем они отличаются?
Что такое checked и unchecked exception?
В Java все исключения делятся на два типа:
    - checked (контролируемые/проверяемые исключения) должны обрабатываться блоком catch или 
описываться в сигнатуре метода (например, throws IOException). Наличие такого обработчика/мо-
дификатора сигнатуры проверяются на этапе компиляции;
    - unchecked (неконтролируемые/непроверяемые исключения), к которым относятся ошибки 
Error (например, OutOfMemoryError), обрабатывать которые не рекомендуется и исключения 
времени выполнения, представленные классом RuntimeException и его наследниками (например, 
NullPointerException), которые могут не обрабатываться блоком catch и не быть описанными в сиг-
натуре метода.
Какой оператор позволяет принудительно выбросить 
исключение?
Это оператор throw:
throw new Exception();
О чем говорит ключевое слово throws?
Модификатор throws прописывается в сигнатуре метода и указывает на то, что метод потенциально 
может выбросить исключение с указанным типом.
Как написать собственное («пользовательское») 
исключение?
Необходимо унаследоваться от базового класса требуемого типа исключений (например от 
Exception или RuntimeException).


class CustomException extends Exception {
    public CustomException() {
        super();
    }
    public CustomException(final String string) {
        super(string + « is invalid»);
    }
    public CustomException(final Throwable cause) {
        super(cause);
    }

}

Какие существуют unchecked exception?
Наиболее часто встречающиеся: ArithmeticException, ClassCastException, ConcurrentModifi
cationException, IllegalArgumentException, IllegalStateException, IndexOutOfBoundsException, 
NoSuchElementException, NullPointerException, UnsupportedOperationException.
Что представляет из себя ошибки 
класса Error?
Ошибки класса Error представляют собой наиболее серьёзные проблемы уровня JVM. Например, 
исключения такого рода возникают, если закончилась память доступная виртуальной машине. Об-
рабатывать такие ошибки не запрещается, но делать этого не рекомендуется.
Что вы знаете о OutOfMemoryError?
OutOfMemoryError выбрасывается, когда виртуальная машина Java не может создать (разместить) 
объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.
Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип OutOfMemoryError 
зависит от того, в какой из них не хватило места:
    java.lang.OutOfMemoryError: Java heap space: Не хватает места в куче, а именно, в области памяти 
в которую помещаются объекты, создаваемые в приложении программно. Обычно проблема кроет-
ся в утечке памяти. Размер задается параметрами -Xms и -Xmx.
    java.lang.OutOfMemoryError: PermGen space: (до версии Java 8) Данная ошибка возникает 
при нехватке места в Permanent области, размер которой задается параметрами -XX:PermSize и 
-XX:MaxPermSize.
    java.lang.OutOfMemoryError: GC overhead limit exceeded: Данная ошибка может возникнуть как 
при переполнении первой, так и второй областей. Связана она с тем, что памяти осталось мало и 
сборщик мусора постоянно работает, пытаясь высвободить немного места. Данную ошибку можно 
отключить с помощью параметра -XX:-UseGCOverheadLimit.
    java.lang.OutOfMemoryError: unable to create new native thread: Выбрасывается, когда нет возмож-
ности создавать новые потоки.
Опишите работу блока try-catch-finally.
try — данное ключевое слово используется для отметки начала блока кода, который потенциально 
может привести к ошибке. catch — ключевое слово для отметки начала блока кода, предназначенно-
го для перехвата и обработки исключений в случае их возникновения. finally — ключевое слово для 


отметки начала блока кода, который является дополнительным. Этот блок помещается после по-
следнего блока catch. Управление передаётся в блок finally в любом случае, было выброшено исклю-
чение или нет.
Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:
try { 
    //код, который потенциально может привести к исключительной ситуации 
} 
catch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //код обработки исключительной ситуации
} 
finally {
    //необязательный блок, код которого выполняется в любом случае

}

Что такое механизм try-with-resources?
Данная конструкция, которая появилась в Java 7, позволяет использовать блок try-catch не заботясь 
о закрытии ресурсов, используемых в данном сегменте кода. Ресурсы объявляются в скобках сразу 
после try, а компилятор уже сам неявно создаёт секцию finally, в которой и происходит освобожде-
ние занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс 
java.lang.Autocloseable.
Общий вид конструкции:
try(/*объявление ресурсов*/) {
    //...
} catch(Exception ex) {
    //...
} finally {
    //...

}

Стоит заметить, что блоки catch и явный finally выполняются уже после того, как закрываются ре-
сурсы в неявном finally.
Возможно ли использование блока try-finally (без catch)?
Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок catch, в 
котором будет обрабатываться необходимое исключение.
Может ли один блок catch отлавливать сразу несколько 
исключений?
В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать 
несколько исключений одним блоком catch:
try {  
    //...
} catch(IOException | SQLException ex) {
    //...

}


Всегда ли исполняется блок finally?
Код в блоке finally будет выполнен всегда, независимо от того, выброшено исключение или нет.
Существуют ли ситуации, когда блок finally не будет 
выполнен?
Например, когда JVM «умирает» - в такой ситуации finally недостижим и не будет выполнен, так как 
происходит принудительный системный выход из программы:
try { 
    System.exit(0); 
} catch(Exception e) { 
    e.printStackTrace(); 
} finally { }
Может ли метод main() выбросить исключение во вне 
и если да, то где будет происходить обработка данного 
исключения?
Может и оно будет передано в виртуальную машину Java (JVM).
Предположим, есть метод, который может выбросить 
IOException и FileNotFoundException в какой 
последовательности должны идти блоки catch? Сколько 
блоков catch будет выполнено?
Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить 
в первый блок catch(Exception ex) {}, иначе все дальнейшие блоки catch() уже ничего не смогут обра-
ботать, т.к. любое исключение будет соответствовать обработчику catch(Exception ex).
Таким образом, исходя из факта, что FileNotFoundException extends IOException сначала нужно об-
работать FileNotFoundException, а затем уже IOException:
void method() {
    try {
        //...
    } catch (FileNotFoundException ex) {
        //...
    } catch (IOException ex) {
        //...
    }

}

Что такое generics?
Generics - это технический термин, обозначающий набор свойств языка позволяющих определять и 
использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных 
тем, что имеют типизированные параметры.
Примером использования обобщенных типов может служить Java Collection Framework. Так, класс 
LinkedList<E> - типичный обобщенный тип. Он содержит параметр E, который представляет тип 


элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов проис-
ходит посредством замены параметризированных типов реальными типами данных. Вместо того, 
чтобы просто использовать LinkedList, ничего не говоря о типе элемента в списке, предлагается 
использовать точное указание типа LinkedList<String>, LinkedList<Integer> и т.п.
Что такое «интернационализация», «локализация»?
Интернационализация (internationalization) - способ создания приложений, при котором их можно 
легко адаптировать для разных аудиторий, говорящих на разных языках.
Локализация (localization) - адаптация интерфейса приложения под несколько языков. Добавление 
нового языка может внести определенные сложности в локализацию интерфейса.
